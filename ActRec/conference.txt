Implementation 
The system consists of three main parts. A \textit{mapper} which translate the action specification language to ASP program. The mapper uses c_taid language convenstions for translation. It stores tha data in a database designed for action specifications and their corresponding rules. Once invoked, mapper outputs the resulting ASP code. The ASP code is then fed into a suitable ASP-solver. This operation is handled by the second component called \textit{solver}. The solver reads the asp program from mapper, invokes ASP-solver, and parse the output into answer sets. Usually before a asp program is solved it needs to be grounded. By grounding, all variables are replaced with equivalent values. This is a necessary step since most of asp-solvers require the code to be varable-free. Normally, grounder gringo is used for grounding programs in c_tain language. Once grounded, asp program is ready to be solved by one of the off-the-shelf asp-solvers. In this project we use clingo for this purpose. Clingo has the advantage of having grounder and solver at one place, meaning that it checks the program for grounding before solving. As mentioned above, solver part is responsible for interacting with asp-solver to get the ansert sets. When answer sets obtained from asp-solver, the solver component sends all answer sets for activity detection. Activity Detection is the third and main component of ActRec system and works as follows. For sake of simplicity, we describe the system with a simple scenario for 'Making Pasta'. There are two ways to detect and recognize the activity in ActRec system. First, by determining the initial and final states and ensuring that these conditions are met in the nswer sets. When initial and final states are provided, the system take all flunets, and for each state, starting from time zero, checks if the initial set is subset of any state. For 'making pasta' scenario, a simple initial condition could be to make sure that 'the heat is on', 'the vessel is on the heat', and 'the vessel has water', alltogether meaning that we are ready to boil water. Now the system looks for a state that holds the afrmentioed condition. If the search is successful, then preconditions for the activity met, i.e. activity is started, otherwise system terminates by activity is not detected. Now the algorithm continues to search and this time looks for the state that satisfies final state conditions. A final state for our making pasta scenario could be simply checking if the sauce is added to pasta. If such a state is found, we have reached both the initial and final conditions for occurance of an activity, meaning that the activity is recognized. Otherwise the algorithm terminates by saying that the activity is started but not finished yet, i.e it is uncomplete. If the activity is recignized, a path from the state meeting the initial conditions, i.e initial state to the state satisfying the final conditions, i.e final state is shown. 
The second method to recognize an activity is to check for occurance of a sequence of actions that are necessary for an activity to occur. For "cooking pasta" scenario, one can check for if, for instance, a sequence of actions such as 'boil the water', 'add pasta to the boiled water', 'drain the water' and 'add sauce to boiled pasta' is performed, then we can infer that 'cooking pasta' activity is performed as the result. 
An overview of the ActRec system is depicted at Fig. \cite{fig:actrec} with its three main components. 